;;;; kate: indent-width 4; replace-tabs yes; space-indent on;

(defun expand-aref-1 (expr old-expr)
    (match expr
        (`(aref ,name ,@idxvals)
            (let* ((idx-cnt    (length idxvals))
                   (stride     nil)
                   (stride-lst
                       (loop for i from (1- idx-cnt) downto 0
                        collect (prog1 stride
                                   (let ((cstride `(arr-dim ,name ,i)))
                                       (setf stride
                                           (if stride
                                               `(* ,stride ,cstride)
                                               cstride))))))
                   (ofs-lst (mapcar #'(lambda (idx istride)
                                          (if istride `(* ,idx ,istride) idx))
                                idxvals (nreverse stride-lst))))
                `(ptr-deref
                     ,(reduce #'(lambda (base ofs) `(ptr+ ,base ,ofs))
                            ofs-lst :initial-value `(arr-ptr ,name)))))
        (_ nil)))

(defun expand-aref (expr)
    (simplify-rec-once #'expand-aref-1 expr))

(defun expand-macros (expr)
    (match expr
        ((type atom _) expr)
        (`(declare ,@_) expr)
        (`(1+ ,v)
            (expand-macros `(+ ,v 1)))
        (`(1- ,v)
            (expand-macros `(- ,v 1)))
        ((cons (or 'ranging 'aref 'iref
                   '+ '- '* '/ 'mod 'rem 'floor 'ceiling 'truncate
                   'and 'or 'if 'progn
                   'sin 'cos 'exp 'expt
                   '> '< '>= '<= '/= '= 'setf 'loop-range) tail)
            (cons-save-old expr (car expr)
                (mapcar-save-old #'expand-macros tail)))
        (`(,(as op (or 'let 'let*)) ,vars ,@body)
            (cons-save-old expr op
                (cons-save-old (cdr expr)
                    (mapcar-save-old
                        #'(lambda (pair)
                              (if (symbolp pair) (cons pair nil)
                                  (cons-save-old pair
                                      (car pair)
                                      (mapcar-save-old #'expand-macros (cdr pair)))))
                        vars)
                    (mapcar-save-old #'expand-macros body))))
        (_
            (multiple-value-bind (res macro) (macroexpand expr)
                (if macro
                    (expand-macros res)
                    (error "Unknown form in compute: ~A" res))))))

(defun get-inline-tag (idx)
    (aref #("0" "1" "2" "3" "4" "5" "6" "7" "8" "9"
            "a" "b" "c" "d" "e" "f" "g" "h" "i" "j"
            "k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
            "u" "v" "w" "x" "y" "z") idx))

(defun compile-expr-sse (full_expr)
    (let ((types (derive-types full_expr))
          (args  ())
          (arg-types ())
          (arg-map (make-hash-table))
          (arr-map (make-hash-table)))
        (labels ((ref-symbol (sym)
                     (if (get sym 'let-clause)
                         (concatenate 'string "tmp_" (symbol-name sym))
                         (ref-arg sym)))
                 (ref-atom (atomv)
                     (if (symbolp atomv) (ref-symbol atomv)
                         (format nil "~S" atomv)))
                 (ref-arg (sym)
                     (let ((sym-type (gethash sym types))
                           (sym-id (gethash sym arg-map)))
                         (unless sym-id
                             (setf sym-id (hash-table-count arg-map))
                             (setf (gethash sym arg-map) sym-id)
                             (push sym args)
                             (push
                                 (match sym-type
                                     ('array :object)
                                     ('float :float)
                                     ('integer :int)
                                     ('boolean :int)
                                     (_ (error "Bad type ~A on input ~A" sym-type sym)))
                                 arg-types))
                         (concatenate 'string "#" (get-inline-tag sym-id))))
                 (use-array (arr dim)
                     (let ((rarr (unwrap-factored arr)))
                         (setf (gethash rarr arr-map)
                             (max dim (or (gethash rarr arr-map) 0)))))
                 (compile-temp-assn (out var expr)
                     (let ((var-type (gethash expr types))
                           (var-name (concatenate 'string "tmp_"
                                         (symbol-name var))))
                         (write-string (match var-type
                                     ('array "cl_object")
                                     ('float "float")
                                     ('float-ptr "float*")
                                     ('integer "int")
                                     ('boolean "int")
                                     (_ (error "Bad type ~A of ~A in ~A"
                                            var-type expr full_expr)))
                             out)
                         (write-string " " out)
                         (write-string var-name out)
                         (write-string " = (" out)
                         (compile-form out expr)
                         (format out ");~%")))
                 (compile-form (out form &optional stmtp)
                     (match form
                         ((type symbol sym)
                             (write-string (ref-symbol sym) out))
                         ((type atom _)
                             (prin1 form out))
                         (`(declare ,@_)
                             (unless stmtp
                                 (write-string "0" out)))
                         (`(ranging ,v ,@_)
                             (if (ranging-loop-level form)
                                 (write-string (symbol-name v) out)
                                 (compile-form out v)))
                         (`(,(as op (or '+ '- '* '/ 'truncate 'rem 'ptr+
                                        'and 'or '> '< '>= '<= '/= '=)) ,a ,b)
                             (write-string "(" out)
                             (compile-form out a)
                             (write-string ")" out)
                             (write-string (case op
                                        ((+ - * / < > >= <=) (symbol-name op))
                                        (/= "!=")
                                        (= "==")
                                        (ptr+ "+")
                                        (and "&&")
                                        (or "||")
                                        (truncate "/")
                                        (rem "%"))
                                 out)
                             (write-string "(" out)
                             (compile-form out b)
                             (write-string ")" out))
                         (`(,(as op (or '+ '-)) ,a)
                             (prin1 op out)
                             (write-string "(" out)
                             (compile-form out a)
                             (write-string ")" out))
                         (`(,(as func (or 'floor 'ceiling 'sin 'cos 'exp 'expt))
                               ,arg ,@rest)
                             (write-string (case func
                                        ('expt "pow")
                                        ('ceiling "ceil")
                                        (t (string-downcase (symbol-name func))))
                                 out)
                             (write-string "(" out)
                             (compile-form out arg)
                             (dolist (arg2 rest)
                                 (write-string ", " out)
                                 (compile-form out arg2))
                             (write-string ")" out))
                         (`(arr-dim ,arr ,idx)
                             (use-array arr idx)
                             (when (= 0 idx)
                                 (write-string "VECTORP(" out)
                                 (compile-form out arr)
                                 (write-string ")?(" out)
                                 (compile-form out arr)
                                 (write-string ")->vector.dim:" out))
                             (write-string "(" out)
                             (compile-form out arr)
                             (format out ")->array.dims[~A]" idx))
                         (`(arr-ptr ,arr)
                             (use-array arr 0)
                             (write-string "VECTORP(" out)
                             (compile-form out arr)
                             (write-string ")?(" out)
                             (compile-form out arr)
                             (write-string ")->vector.self.sf:(" out)
                             (compile-form out arr)
                             (write-string ")->array.self.sf" out))
                         (`(ptr-deref ,ptr)
                             (write-string "*(" out)
                             (compile-form out ptr)
                             (write-string ")" out))
                         (`(if ,icond ,a ,b)
                             (write-string "(" out)
                             (compile-form out icond)
                             (write-string ") ? (" out)
                             (compile-form out a)
                             (write-string ") : (" out)
                             (compile-form out b)
                             (write-string ")" out))
                         (`(let* ,assns ,@body)
                             (write-line "{" out)
                             (dolist (assn assns)
                                 (compile-temp-assn out
                                     (first assn) (second assn)))
                             (dolist (cmd body)
                                 (compile-form out cmd t))
                             (write-line "}" out))
                         (`(setf ,target ,expr)
                             (compile-form out target)
                             (write-string " = (" out)
                             (compile-form out expr)
                             (write-string ")" out)
                             (when stmtp (write-line ";" out)))
                         (`(loop-range
                              (ranging ,arg ,min ,max ,delta ,@_)
                              ,@body)
                             (format out "{~%int ~A;~%for(~A = " arg arg)
                             (compile-form out (if (> delta 0) min max))
                             (format out "; ~A ~A " arg (if (> delta 0) "<=" ">="))
                             (compile-form out (if (> delta 0) max min))
                             (format out "; ~A += ~A) {~%" arg delta)
                             (dolist (cmd body)
                                 (compile-form out cmd t))
                             (write-line "}}" out))
                         ((when stmtp `(progn ,@body))
                             (dolist (cmd body)
                                 (compile-form out cmd t)))
                         (`(progn ,cmd1 ,@rest)
                             (compile-form out cmd1)
                             (dolist (cmd rest)
                                 (write-string ", " out)
                                 (compile-form out cmd)))
                         (`(safety-check ,checks ,@body)
                             (dolist (check checks)
                                 (write-string "if (!(" out)
                                 (compile-form out check)
                                 (write-line "))" out)
                                 (format out "    FEerror(\"Safety check failed: ~A\",0);~%" check))
                             (dolist (cmd body)
                                 (compile-form out cmd t)))
                         (_
                             (error "Unrecognized form in compile-sse: ~A" form)))))
            (let ((code (with-output-to-string (out)
                            (compile-form out full_expr)))
                  (arr-conds ()))
                ;; Collect array checks
                (maphash #'(lambda (arr dim)
                               (push `(eql (array-element-type ,arr) 'single-float)
                                   arr-conds)
                               (push `(>= (length (array-dimensions ,arr)) ,(1+ dim))
                                   arr-conds))
                    arr-map)
                ;; Generate the code
                `(safety-check ,(nreverse arr-conds)
                    (ffi:clines "#include <math.h>")
                    (ffi:c-inline ,(nreverse args) ,(nreverse arg-types)
                         :void ,code))))))

(define-compiler-macro compute (&whole original name idxspec expr &key with)
    (handler-bind ((condition
                       #'(lambda (cond)
                             (format t "~%Fast C compilation failed:~%   ~A~%" cond)
                             (format t "Reverting to ordinary lisp.~%")
                             (return-from compute original))))
        (multiple-value-bind
                (indexes layout dimensions) (get-multivalue-info name)
            (let* ((idxtab    (mapcar #'cons indexes idxspec))
                   (idxord    (reorder idxtab layout #'caar))
                   (idxlist   (mapcan #'get-iter-spec idxord))
                   (idxvars   (mapcar #'get-index-var idxspec))
                   (let-expr  (if with `(let* ,with ,expr) expr))
                   (full-expr `(setf (iref ,name ,@idxvars) ,let-expr))
                   (loop-expr (wrap-idxloops name indexes idxlist
                                  (list full-expr) :min-layer 0))
                   (nomacro-expr (expand-macros loop-expr))
                   (nolet-expr (expand-let nomacro-expr))
                   (*consistency-checks* (make-hash-table :test #'equal))
                   (noiref-expr (simplify-iref nolet-expr))
                   (noaref-expr (expand-aref noiref-expr))
                   (check-expr  (insert-checks noaref-expr))
                   (motion-expr (code-motion check-expr :pull-symbols t)))
                `(let ((*current-compute* ',original))
                    ,(compile-expr-sse motion-expr))))))
