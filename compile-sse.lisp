;;;; kate: indent-width 4; replace-tabs yes; space-indent on;

(in-package fast-compute)

(defun compile-expr-sse (types ext-vars full_expr)
    (let ((aux-vars ()))
        (labels ((get-type (expr)
                     (gethash (unwrap-factored expr) types))
                 (ref-extvar (name)
                     (incf-nil (gethash name ext-vars))
                     (format nil "~A_4" name))
                 (ref-symbol (sym)
                     (if (get sym 'let-clause)
                         (concatenate 'string "tmp_" (symbol-name sym))
                         (error "Non-local symbol in SSE: ~A" sym)))
                 (compile-temp-assn (out var expr)
                     (let ((var-type (gethash expr types))
                           (var-name (concatenate 'string "tmp_"
                                         (symbol-name var)))
                           (var-fdiv (or (get var 'fdiv-users) 0)))
                         (write-string
                             (case var-type
                                 (float "__m128")
                                 (boolean "__m128")
                                 (float-ptr "float*")
                                 ((integer boolean)
                                     (return-from compile-temp-assn))
                                 (t
                                     (error "Bad type ~A of ~A in SSE ~A"
                                         var-type expr full_expr)))
                             out)
                         (write-string " " out)
                         (write-string var-name out)
                         (write-string " = (" out)
                         (case var-type
                             (float-ptr
                                 (compile-form-ptr out expr))
                             (t
                                 (compile-form-float out expr)))
                         (format out ");~%")
                         (when (> var-fdiv 1)
                             (format out
                                 "__m128 ~A_fdiv = _mm_div_ps(_mm_set1_ps(1.0),~A);~%"
                                 var-name var-name))))
                 (is-level0-ptr (form)
                     (match form
                         ((type symbol sym)
                             (let ((level (get sym 'loop-level 'unknown)))
                                 (when (eql level 'unknown)
                                     (error "Unmarked symbol in SSE ptr: ~A" sym))
                                 (if (eql level 0)
                                     (is-level0-ptr (unwrap-factored sym))
                                     nil)))
                         ((type number num)
                             nil)
                         (`(ranging ,v ,@_)
                             (eql (ranging-loop-level form) 0))
                         (`(ptr+ ,ptr ,ofs)
                             (let ((ptr-0 (is-level0-ptr ptr))
                                   (ofs-0 (is-level0-ptr ofs)))
                                 (if (and ptr-0 ofs-0)
                                     (error "Pointer too complex in SSE: ~A" form))
                                 (or ptr-0 ofs-0)))
                         (`(,(or '+ '-) ,a ,(type number b))
                             (is-level0-ptr a))
                         (`(+ ,(type number b) ,a)
                             (is-level0-ptr a))
                         (_
                             (error "Expression too complex in SSE ptr: ~A" form))))
                 (compile-form-ptr (out form)
                     (match form
                         ((type symbol sym)
                             (let ((level (get sym 'loop-level))
                                   (stype (get-type sym)))
                                 (if (and (eql level 0)
                                          (not (eql stype 'float-ptr)))
                                     (compile-form-ptr out
                                         (unwrap-factored sym))
                                     (write-string (ref-symbol sym) out))))
                         ((type number num)
                             (format out "~A" num))
                         (`(ranging ,v ,@_)
                             (write-string (symbol-name v) out))
                         (`(ptr+ ,ptr ,ofs)
                             (write-string "(" out)
                             (compile-form-ptr out ptr)
                             (write-string ")+(" out)
                             (compile-form-ptr out ofs)
                             (write-string ")" out))
                         ((or
                             `(,(as op (or '+ '-)) ,a ,(type number b))
                             `(,(as op '+) ,(type number b) ,a))
                             (write-string "(" out)
                             (compile-form-ptr out a)
                             (format out ")~A(~A)" op b))
                         (_
                             (error "Invalid ptr form: ~A" form))))
                 (compile-form-float (out form)
                     (match form
                         ((type symbol sym)
                             (let ((sym-type (get-type sym))
                                   (sym-level (get sym 'loop-level))
                                   (sym-name (ref-symbol sym)))
                                 (cond
                                     ((and (eql sym-level 0)
                                           (or (eql sym-type 'float)
                                               (eql sym-type 'boolean)))
                                         (write-string sym-name out))
                                     ((eql sym-level 0)
                                         (compile-form-float out
                                             (unwrap-factored sym)))
                                     ((eql sym-type 'boolean)
                                         (error "Boolean -> sse cast not implemented"))
                                     (t
                                         (write-string (ref-extvar sym-name) out)))))
                         ((when (= val 0) (type number val))
                             (write-string "_mm_setzero_ps()" out))
                         ((type atom val)
                             (format out "_mm_set1_ps(~A)" val))
                         (`(declare ,@_)
                             (write-string "0" out))
                         (`(_grp ,x)
                             (compile-form-float out x))
                         (`(tmp-ref ,x)
                             (compile-form-float out x))
                         (`(ranging ,v ,@_)
                             (if (eql (ranging-loop-level form) 0)
                                 (format out
                                     "_mm_add_ps(_mm_set1_ps(~A),_mm_setr_ps(0,1,2,3))"
                                     (symbol-name v))
                                 (write-string (ref-extvar (symbol-name v)) out)))
                         ((when (> (or (get sym 'fdiv-users) 0) 1)
                             `(/ ,x ,(type symbol sym)))
                             (if (and (numberp x)
                                      (= x 1))
                                 (write-string "(" out)
                                 (progn
                                     (write-string "_mm_mul_ps(" out)
                                     (compile-form-float out x)
                                     (write-string "," out)))
                             (let ((fd-name (format nil "~A_fdiv" (ref-symbol sym))))
                                 (if (eql (get sym 'loop-level) 0)
                                     (write-string fd-name out)
                                     (write-string (ref-extvar fd-name) out)))
                             (write-string ")" out))
                         (`(/ ,x ,(type number num))
                             (write-string "_mm_mul_ps(" out)
                             (compile-form-float out x)
                             (format out ",_mm_set1_ps(1.0/~A))" num))
                         (`(/ ,(type number num))
                             (format out "_mm_set1_ps(1.0/~A)" num))
                         (`(/ ,x)
                             (write-string "_mm_div_ps(_mm_set1_ps(1.0)," out)
                             (compile-form-float out x)
                             (write-string ")" out))
                         (`(,(as op (or '+ '- '* '/ 'max 'min
                                        'and 'or '> '< '>= '<= '/= '=)) ,a ,b)
                             (write-string (case op
                                        (+ "_mm_add_ps")
                                        (- "_mm_sub_ps")
                                        (* "_mm_mul_ps")
                                        (/ "_mm_div_ps")
                                        (< "_mm_cmplt_ps")
                                        (> "_mm_cmpgt_ps")
                                        (<= "_mm_cmple_ps")
                                        (>= "_mm_cmpge_ps")
                                        (/= "_mm_cmpneq_ps")
                                        (= "_mm_cmpeq_ps")
                                        (and "_mm_and_ps")
                                        (or "_mm_or_ps")
                                        (max "_mm_max_ps")
                                        (min "_mm_min_ps"))
                                 out)
                             (write-string "(" out)
                             (compile-form-float out a)
                             (write-string "," out)
                             (compile-form-float out b)
                             (write-string ")" out))
                         (`(+ ,a)
                             (compile-form-float out a))
                         (`(- ,a)
                             (write-string "_mm_sub_ps(_mm_setzero_ps()," out)
                             (compile-form-float out a)
                             (write-string ")" out))
                         (`(,(as func (or 'floor 'ceiling 'sin 'cos 'exp 'expt)) ,@_)
                             (error "Functions not supported in SSE: ~A" func))
                         (`(ptr-deref ,ptr)
                             (if (is-level0-ptr ptr)
                                 (progn
                                     (write-string "_mm_loadu_ps(" out)
                                     (compile-form-ptr out ptr)
                                     (write-string ")" out))
                                 (progn
                                     (write-string "_mm_set1_ps(*(" out)
                                     (compile-form-ptr out ptr)
                                     (write-string "))" out))))
                         ((when (and (= a 0) (= b 0))
                             `(if ,_ ,(type number a) ,(type number b)))
                             (write-string "_mm_setzero_ps()"))
                         ((when (or (and (numberp a) (= a 0))
                                    (and (numberp b) (= b 0)))
                              `(if ,icond ,a ,b))
                             (let ((a-zero (and (numberp a) (= a 0))))
                                 (write-string
                                     (if a-zero "_mm_andnot_ps(" "_mm_and_ps(")
                                     out)
                                 (compile-form-float out icond)
                                 (write-line "," out)
                                 (compile-form-float out (if a-zero b a))
                                 (write-string ")" out)))
                         (`(if ,icond ,a ,b)
                             (let* ((tmp-var (gensym))
                                    (tmp-name (symbol-name tmp-var)))
                                 (push tmp-name aux-vars)
                                 (format out  "(~A = (" tmp-name)
                                 (compile-form-float out icond)
                                 (write-line ")," out)
                                 (write-string "_mm_or_ps(" out)
                                 (format out "_mm_and_ps(~A," tmp-name)
                                 (compile-form-float out a)
                                 (write-line ")," out)
                                 (format out "_mm_andnot_ps(~A," tmp-name)
                                 (compile-form-float out b)
                                 (write-line ")" out))
                                 (write-string "))" out))
                         (`(setf (ptr-deref ,target) ,expr)
                             (let* ((tmp-var (gensym))
                                    (tmp-name (symbol-name tmp-var)))
                                 (unless (is-level0-ptr target)
                                     (error "Store to a non-inner ptr in SSE: ~A" form))
                                 (push tmp-name aux-vars)
                                 (format out  "(~A = (" tmp-name)
                                 (compile-form-float out expr)
                                 (write-line ")," out)
                                 (write-string "_mm_storeu_ps(" out)
                                 (compile-form-ptr out target)
                                 (format out ", ~A), ~A)" tmp-name tmp-name)))
                         (`(progn ,cmd1 ,@rest)
                             (write-string "(" out)
                             (compile-form-float out cmd1)
                             (dolist (cmd rest)
                                 (write-line "," out)
                                 (compile-form-float out cmd))
                             (write-string ")" out))
                         (_
                             (error "Unrecognized form in compile-sse(float): ~A" form))))
                 (compile-form-structure (out form)
                     (match form
                         (`(let* ,assns ,@body)
                             (write-line "{" out)
                             (dolist (assn assns)
                                 (compile-temp-assn out
                                     (first assn) (second assn)))
                             (dolist (cmd body)
                                 (compile-form-structure out cmd))
                             (write-line "}" out))
                         (`(setf (ptr-deref ,target) ,expr)
                             (unless (is-level0-ptr target)
                                 (error "Store to a non-inner ptr in SSE: ~A" form))
                             (write-string "_mm_storeu_ps(" out)
                             (compile-form-ptr out target)
                             (write-line "," out)
                             (compile-form-float out expr)
                             (write-line ");" out))
                         (`(progn ,@body)
                             (dolist (cmd body)
                                 (compile-form-structure out cmd)))
                         (_
                             (error "Unrecognized form in compile-sse(structure): ~A" form)))))
            (handler-bind ((condition
                   #'(lambda (cond)
                         (format t "~%SSE compilation failed:~%   ~A~%" cond)
                         (format t "Reverting to ordinary C.~%")
                         (return-from compile-expr-sse nil))))
                (let ((code (with-output-to-string (out)
                                (compile-form-structure out full_expr)))
                      (vars (if (null aux-vars) ""
                                (format nil "__m128 ~{~A~^, ~};~%" aux-vars))))
                    (concatenate 'string vars code))))))

(defun compile-expr-generic (full_expr)
    (let ((types (derive-types full_expr))
          (args  ())
          (arg-types ())
          (arg-map (make-hash-table))
          (arr-map (make-hash-table)))
        (labels ((ref-symbol (sym)
                     (if (get sym 'let-clause)
                         (temp-symbol-name sym)
                         (ref-arg sym)))
                 (ref-arg (sym)
                     (let ((sym-type (gethash sym types))
                           (sym-id (gethash sym arg-map)))
                         (unless sym-id
                             (setf sym-id (hash-table-count arg-map))
                             (setf (gethash sym arg-map) sym-id)
                             (push sym args)
                             (push
                                 (match sym-type
                                     ('array :object)
                                     ('float :float)
                                     ('integer :int)
                                     ('boolean :int)
                                     (_ (error "Bad type ~A on input ~A" sym-type sym)))
                                 arg-types))
                         (concatenate 'string "#" (get-inline-tag sym-id))))
                 (use-array (arr dim)
                     (let ((rarr (unwrap-factored arr)))
                         (setf (gethash rarr arr-map)
                             (max dim (or (gethash rarr arr-map) 0))))))
            (let*
                ((spec-compiler
                     (form-compiler (form)
                         ((type symbol sym)
                             (text (ref-symbol sym)))
                         (`(multivalue-data ,@_)
                             (text (ref-arg form)))
                         (`(arr-dim ,arr ,idx)
                             (use-array arr idx)
                             (let ((arr-str (recurse-str arr)))
                                 (when (= 0 idx)
                                     (text "VECTORP(~A)?(~A)->vector.dim:"
                                         arr-str arr-str))
                                 (text "(~A)->array.dims[~A]"
                                     arr-str idx)))
                         (`(arr-ptr ,arr)
                             (use-array arr 0)
                             (let ((arr-str (recurse-str arr)))
                                 (text "VECTORP(~A)?(~A)->vector.self.sf:(~A)->array.self.sf"
                                     arr-str arr-str arr-str)))
                         (`(loop-range
                              (ranging ,arg ,min ,max 1 nil 0 ,@_)
                              ,@body)
                             (text "{~%int ~A = " arg)
                             (recurse min)
                             (text ";~%")
                             (let* ((ext-vars (make-hash-table :test #'equal))
                                    (sse-code (compile-expr-sse types ext-vars `(progn ,@body))))
                                 (when sse-code
                                     (text "{")
                                     (maphash #'(lambda (v n)
                                                    (text "__m128 ~A_4 = _mm_set1_ps(~A);~%" v v))
                                         ext-vars)
                                     (text "for (; ~A <= (" arg)
                                     (recurse max)
                                     (text ")-3; ~A += 4) {~%" arg)
                                     (text sse-code)
                                     (text "}}~%")))
                             (text "for (; ~A <= " arg)
                             (recurse max)
                             (text "; ~A++) {~%" arg)
                             (dolist (cmd body)
                                 (recurse cmd :stmt-p t))
                             (text "}}~%"))
                         (`(loop-range
                              (ranging ,arg ,min ,max ,delta ,@_)
                              ,@body)
                             (when (eql (ranging-loop-level (second form)) 0)
                                 (format t "SSE inapplicable: ~A~%" (second form)))
                             (text "{~%int ~A;~%for(~A = " arg arg)
                             (recurse (if (> delta 0) min max))
                             (text "; ~A ~A " arg (if (> delta 0) "<=" ">="))
                             (recurse (if (> delta 0) max min))
                             (text "; ~A += ~A) {~%" arg delta)
                             (dolist (cmd body)
                                 (recurse cmd :stmt-p t))
                             (text "}}~%"))
                         (`(safety-check ,checks ,@body)
                             (dolist (check checks)
                                 (text "if (!(")
                                 (recurse (first check))
                                 (text "))~%    FEerror(\"Safety check failed: ~A\",0);~%"
                                     (second check)))
                             (dolist (cmd body)
                                 (recurse cmd :stmt-p t)))))

                 (*cg-type-table* types)
                 (code (call-form-compilers
                           (list spec-compiler
                                 #'compile-generic-c
                                 #'compile-c-inline-temps)
                           full_expr :stmt-p t))
                 (checks (with-output-to-string (out)
                             (maphash
                                 #'(lambda (arr dim)
                                       (format out "{ cl_object arr = ~A; /* ~A */~%"
                                           (ref-arg arr) arr)
                                       (format out
                                           "if (!ARRAYP(arr) && !VECTORP(arr))~%  FEerror(\"Not an array: ~A\",0);~%"
                                           arr)
                                       (write-line
                                           "if ((VECTORP(arr)?arr->vector.elttype:arr->array.elttype)!=aet_sf)"
                                           out)
                                       (format out "  FEerror(\"Not a float array: ~A\",0);~%" arr)
                                       (when (> dim 0)
                                           (format out
                                               "if (!ARRAYP(arr) || arr->array.rank <= ~A)~%  FEerror(\"Too few dimensions: ~A\",0);~%"
                                               dim arr))
                                       (write-line "};" out))
                                   arr-map))))
                ;; Generate the code
                `(progn
                    (ffi:clines "#include <math.h>")
                    (ffi:clines "#include <emmintrin.h>")
                    (ffi:c-inline ,(nreverse args) ,(nreverse arg-types)
                         :void ,(format nil "~A{~%~A}~%" checks code)))))))

(define-compiler-macro compute (&whole original name idxspec expr
                                   &key with where carrying parallel cluster-cache)
    (handler-bind ((condition
                       #'(lambda (cond)
                             (format t "~%Fast C compilation failed:~%   ~A~%" cond)
                             (format t "Reverting to ordinary lisp.~%")
                             (return-from compute original))))
        (let* ((*current-compute* original)
               (*consistency-checks* (make-hash-table :test #'equal)))
            (multiple-value-bind
                    (loop-expr loop-list range-list)
                    (make-compute-loops name idxspec expr with where carrying cluster-cache)
                (let* ((nomacro-expr (expand-macros loop-expr))
                       (nolet-expr   (expand-let nomacro-expr))
                       (noiref-expr (simplify-iref nolet-expr))
                       (ref-list    (collect-arefs noiref-expr))
                      ; (opt-expr    (optimize-tree noiref-expr))
                       (noaref-expr (expand-aref noiref-expr))
                       (check-expr  (insert-checks noaref-expr)))
                    (wrap-compute-sync-data :host ref-list
                        (wrap-compute-parallel parallel range-list check-expr
                            #'(lambda (code)
                                 `(let ((*current-compute* ',original))
                                      ,(compile-expr-generic
                                           (code-motion code :pull-symbols t)))))))))))
