;;;; kate: indent-width 4; replace-tabs yes; space-indent on;

(in-package fast-compute)

(defparameter *range-cache* (make-hash-table))

(defun compute-range-ranging (expr prev-expr)
    (if (equal expr prev-expr)
        expr
        (compute-range-ranging
            (match expr
                ((when (or (get smin 'full-expr)
                           (get smax 'full-expr))
                    (ranging-spec arg (type symbol smin) (type symbol smax) delta))
                    (ranging-spec arg (get-full-expr smin) (get-full-expr smax) delta))
                ((ranging-spec arg (ranging-spec _ :min minv) maxv delta)
                    (ranging-spec arg minv maxv delta))
                ((ranging-spec arg minv (ranging-spec _ :max maxv) delta)
                    (ranging-spec arg minv maxv delta))
                ((ranging-spec arg `(max ,smin1 ,smin2) maxv delta)
                    (let* ((range1 (compute-any-range smin1))
                           (range2 (compute-any-range smin2))
                           (rval
                               (case
                                   (compare-indexes
                                       (or (car range1) smin1)
                                       (or (car range2) smin2))
                                   ((> =) smin1)
                                   (< smin2)
                                   (t (third expr)))))
                        (ranging-spec arg rval maxv delta)))
                ((ranging-spec arg minv `(min ,smax1 ,smax2) delta)
                    (let* ((range1 (compute-any-range smax1))
                           (range2 (compute-any-range smax2))
                           (rval
                               (case
                                   (compare-indexes
                                       (or (cdr range1) smax1)
                                       (or (cdr range2) smax2))
                                   ((< =) smax1)
                                   (> smax2)
                                   (t (fourth expr)))))
                        (ranging-spec arg minv rval delta)))
                (_ expr))
            expr)))


(defun compute-range-1 (expr &optional (old-expr expr))
    (match expr
        ((ranging-spec _)
            (compute-range-ranging (simplify-index expr) nil))
        (`(- ,(ranging-spec arg min max delta))
            (ranging-spec `(- ,arg) `(- ,max) `(- ,min) `(- ,delta)))
        (`(,(as op (or '+ '-))
              ,(ranging-spec arg min max delta)
              ,(ranging-spec arg2 min2 max2 _))
            (ranging-spec `(,op ,arg ,arg2)
                 `(,op ,min ,(if (eql op '+) min2 max2))
                 `(,op ,max ,(if (eql op '+) max2 min2))
                 delta))
        (`(,(as op (or '+ '-))
              ,(ranging-spec arg min max delta) ,@pv)
            (ranging-spec `(,op ,arg ,@pv)
                `(,op ,min ,@pv) `(,op ,max ,@pv) delta))
        (`(mod ,(ranging-spec arg min max delta)
              ,(type number num))
            (ranging-spec `(mod ,arg ,num) 0 (1- num) delta))
        ((when (and (numberp mv) (>= mv 0))
            `(,(as op (or '* '/ 'floor))
                 ,(ranging-spec arg min max delta) ,mv))
            (ranging-spec `(,op ,arg ,mv)
                `(,op ,min ,mv) `(,op ,max ,mv) `(,op ,delta ,mv)))
        ((when (and (numberp mv) (< mv 0))
            `(,(as op (or '* '/ 'floor))
                 ,(ranging-spec arg min max delta) ,mv))
            (ranging-spec `(,op ,arg ,mv)
                `(,op ,max ,mv) `(,op ,min ,mv) `(,op ,delta ,mv)))
        (_ nil)))

(defun compute-range (expr)
    (let ((cached (gethash expr *range-cache*))
          (*simplify-ranges* t))
        (if cached cached
            (setf (gethash expr *range-cache*)
                (simplify-index
                    (simplify-rec-once #'compute-range-1 expr))))))

(defun compare-indexes (expr1 expr2 &optional (delta 0))
    (match (cons expr1 expr2)
        (`((+ ,le ,(type number lv)) . ,_)
            (compare-indexes le expr2 (+ delta lv)))
        (`((- ,le ,(type number lv)) . ,_)
            (compare-indexes le expr2 (- delta lv)))
        (`(,_ . (+ ,re ,(type number rv)))
            (compare-indexes expr1 re (- delta rv)))
        (`(,_ . (- ,re ,(type number rv)))
            (compare-indexes expr1 re (+ delta rv)))
        (`((* ,le ,(type number lv)) . (* ,re ,lv))
            (compare-indexes le re (/ delta lv)))
        (`((,(or '/ 'floor) ,le ,(type number lv)) . (,(or '/ 'floor) ,re ,lv))
            (compare-indexes le re (* delta lv)))
        ((when (equal expr1 expr2))
            (cond ((< delta 0) '<)
                  ((> delta 0) '>)
                  (t '=)))
        (`(,(type number lv) . ,(type number rv))
            (compare-indexes 0 0 (+ delta (- lv rv))))
        (`(,expr1 . (* (floor ,expr2 ,base) ,base))
            (if (eql (compare-indexes expr1 expr2 delta) '=)
                '>))
        (`(,expr1 . (* (ceiling ,expr2 ,base) ,base))
            (if (eql (compare-indexes expr1 expr2 delta) '=)
                '<))
        (`((,(or '/ 'floor) ,le ,(type number lv)) . ,re)
            (compare-indexes le `(* ,re ,lv) (* delta lv)))
        (`((* ,le ,(type number lv)) . ,re)
            (compare-indexes le `(/ ,re ,lv) (/ delta lv)))
        (_ nil)))

(defun compute-num-range (expr)
    (match (compute-range expr)
        ((type number val)
            (cons val val))
        ((ranging-spec _ :min (type number min) :max (type number max))
            (cons min max))
        (_ nil)))

(defun compute-any-range (expr)
    (match (compute-range expr)
        ((type number val)
            (cons val val))
        ((ranging-spec _ :min minv :max maxv)
            (cons minv maxv))
        (_ nil)))
