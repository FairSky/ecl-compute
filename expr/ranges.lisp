;;;; kate: indent-width 4; replace-tabs yes; space-indent on;

(in-package fast-compute)

(defparameter *range-cache* (make-hash-table))

(defun compute-range-ranging (expr prev-expr)
    (if (equal expr prev-expr)
        expr
        (compute-range-ranging
            (match expr
                ((when (or (get smin 'full-expr)
                           (get smax 'full-expr))
                    `(ranging ,arg ,(type symbol smin) ,(type symbol smax) ,@rest))
                    `(ranging ,arg
                         ,(get-full-expr smin)
                         ,(get-full-expr smax)
                         ,@rest))
                (`(ranging ,arg (ranging ,_ ,minv ,@_) ,maxv ,@rest)
                    `(ranging ,arg ,minv ,maxv ,@rest))
                (`(ranging ,arg ,minv (ranging ,_ ,_ ,maxv ,@_) ,@rest)
                    `(ranging ,arg ,minv ,maxv ,@rest))
                (`(ranging ,arg (max ,smin1 ,smin2) ,maxv ,@rest)
                    (let* ((range1 (compute-any-range smin1))
                           (range2 (compute-any-range smin2))
                           (rval
                               (case
                                   (compare-indexes
                                       (or (car range1) smin1)
                                       (or (car range2) smin2))
                                   ((> =) smin1)
                                   (< smin2)
                                   (t (third expr)))))
                        `(ranging ,arg ,rval ,maxv ,@rest)))
                (`(ranging ,arg ,minv (min ,smax1 ,smax2) ,@rest)
                    (let* ((range1 (compute-any-range smax1))
                           (range2 (compute-any-range smax2))
                           (rval
                               (case
                                   (compare-indexes
                                       (or (cdr range1) smax1)
                                       (or (cdr range2) smax2))
                                   ((< =) smax1)
                                   (> smax2)
                                   (t (fourth expr)))))
                        `(ranging ,arg ,minv ,rval ,@rest)))
                (_ expr))
            expr)))

(defun compute-range-1 (expr &optional (old-expr expr))
    (match expr
        (`(ranging ,@_)
            (compute-range-ranging (simplify-index expr) nil))
        (`(- (ranging ,arg ,min ,max ,delta ,@rest))
            `(ranging (- ,arg) (- ,max) (- ,min) (- ,delta) ,@rest))
        (`(,(as op (or '+ '-))
              (ranging ,arg ,min ,max ,@rest)
              (ranging ,arg2 ,min2 ,max2 ,@_))
            `(ranging (,op ,arg ,arg2)
                 (,op ,min ,(if (eql op '+) min2 max2))
                 (,op ,max ,(if (eql op '+) max2 min2))
                 ,@rest))
        (`(,(as op (or '+ '-))
              (ranging ,arg ,min ,max ,@rest) ,@pv)
            `(ranging (,op ,arg ,@pv)
                 (,op ,min ,@pv) (,op ,max ,@pv) ,@rest))
        (`(mod (ranging ,arg ,min ,max ,@rest)
              ,(type number num))
            `(ranging (mod ,arg ,num) 0 ,(1- num) ,@rest))
        ((when (and (numberp mv) (>= mv 0))
            `(,(as op (or '* '/ 'floor))
                 (ranging ,arg ,min ,max ,delta ,@rest) ,mv))
            `(ranging (,op ,arg ,mv)
                 (,op ,min ,mv) (,op ,max ,mv) (,op ,delta ,mv) ,@rest))
        ((when (and (numberp mv) (< mv 0))
            `(,(as op (or '* '/ 'floor))
                 (ranging ,arg ,min ,max ,delta ,@rest) ,mv))
            `(ranging (,op ,arg ,mv)
                 (,op ,max ,mv) (,op ,min ,mv) (,op ,delta ,mv) ,@rest))
        (_ nil)))

(defun compute-range (expr)
    (let ((cached (gethash expr *range-cache*)))
        (if cached cached
            (setf (gethash expr *range-cache*)
                (simplify-index
                    (simplify-rec-once #'compute-range-1 expr))))))

(defun compare-indexes (expr1 expr2 &optional (delta 0))
    (match (cons expr1 expr2)
        (`((+ ,le ,(type number lv)) . ,_)
            (compare-indexes le expr2 (+ delta lv)))
        (`((- ,le ,(type number lv)) . ,_)
            (compare-indexes le expr2 (- delta lv)))
        (`(,_ . (+ ,re ,(type number rv)))
            (compare-indexes expr1 re (- delta rv)))
        (`(,_ . (- ,re ,(type number rv)))
            (compare-indexes expr1 re (+ delta rv)))
        (`((* ,le ,(type number lv)) . (* ,re ,lv))
            (compare-indexes le re (/ delta lv)))
        (`((,(or '/ 'floor) ,le ,(type number lv)) . (,(or '/ 'floor) ,re ,lv))
            (compare-indexes le re (* delta lv)))
        ((when (equal expr1 expr2))
            (cond ((< delta 0) '<)
                  ((> delta 0) '>)
                  (t '=)))
        (`(,(type number lv) . ,(type number rv))
            (compare-indexes 0 0 (+ delta (- lv rv))))
        (`(,expr1 . (* (floor ,expr2 ,base) ,base))
            (if (eql (compare-indexes expr1 expr2 delta) '=)
                '>))
        (`(,expr1 . (* (ceiling ,expr2 ,base) ,base))
            (if (eql (compare-indexes expr1 expr2 delta) '=)
                '<))
        (`((,(or '/ 'floor) ,le ,(type number lv)) . ,re)
            (compare-indexes le `(* ,re ,lv) (* delta lv)))
        (`((* ,le ,(type number lv)) . ,re)
            (compare-indexes le `(/ ,re ,lv) (/ delta lv)))
        (_ nil)))

(defun compute-num-range (expr)
    (match (compute-range expr)
        ((type number val)
            (cons val val))
        (`(ranging ,_ ,(type number min) ,(type number max) ,@_)
            (cons min max))
        (_ nil)))

(defun compute-any-range (expr)
    (match (compute-range expr)
        ((type number val)
            (cons val val))
        (`(ranging ,_ ,minv ,maxv ,@_)
            (cons minv maxv))
        (_ nil)))
